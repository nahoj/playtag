#!/usr/bin/env ruby
# Playtag - Ruby implementation
# Read/Write Playtag tags for media files
# Dependencies: taglib-ruby and mkvtoolnix gems

begin
  require 'taglib'
  require 'fileutils'
  require 'readline'
  require 'optparse'
rescue LoadError => e
  puts "Error: #{e.message}"
  puts "Please install the required dependencies."
  exit 1
end

class PlaytagTag
  PLAYTAG_KEY = "----:com.apple.iTunes:PlayTag"
  VERSION = "v1"

  # Read playtag tag from file
  def self.read(file_path)
    unless File.exist?(file_path)
      warn "Error: File not found: #{file_path}"
      return nil
    end

    # Check file type based on extension
    case File.extname(file_path).downcase
    when ".mp4", ".m4a", ".m4v"
      read_mp4_tags(file_path)
    when ".mp3"
      read_mp3_tags(file_path)
    when ".flac"
      read_flac_tags(file_path)
    when ".mkv"
      warn "MKV support not implemented"
      return nil
    else
      warn "Unsupported file format: #{File.extname(file_path)}"
      return nil
    end
  end

  # Write playtag tag to file
  def self.write(file_path, tag_value)
    unless tag_value.start_with?("#{VERSION};")
      tag_value = "#{VERSION}; #{tag_value}"
    end

    # Check file type based on extension
    case File.extname(file_path).downcase
    when ".mp4", ".m4a", ".m4v"
      write_mp4_tags(file_path, tag_value)
    when ".mp3"
      write_mp3_tags(file_path, tag_value)
    when ".flac"
      write_flac_tags(file_path, tag_value)
    when ".mkv"
      warn "MKV support not implemented"
      return false
    else
      warn "Unsupported file format: #{File.extname(file_path)}"
      return false
    end
  end

  # Parse playtag tag string to options hash
  # Returns a hash of string options
  def self.parse_tag_to_options(tag_str)
    return {} if tag_str.nil? || tag_str.empty?

    # Remove version prefix
    tag_str = tag_str.sub(/^v\d+;\s*/, '')

    # Parse options
    options = {}
    tag_str.split(';').each do |opt|
      opt = opt.strip
      next if opt.empty?

      parts = opt.split('=', 2)
      if parts.size == 2
        key = parts[0].strip
        value = parts[1].strip
        options[key] = value
      else
        # Handle boolean options
        options[opt] = true
      end
    end

    options
  end

  # Convert options hash back to tag string
  def self.options_to_tag(options)
    return "#{VERSION}; " if options.nil? || options.empty?

    parts = ["#{VERSION}"]

    options.each do |key, value|
      if value == true
        parts << key
      else
        parts << "#{key}=#{value}"
      end
    end

    parts.join("; ")
  end

  # Parse time string to seconds
  def self.parse_time(time_str)
    if time_str =~ /^\d+$/
      # Simple seconds
      return time_str.to_f
    elsif time_str =~ /^(\d+):(\d+)(?::(\d+))?(?:\.(\d+))?$/
      # HH:MM:SS.mmm format
      hours = $1.to_i
      minutes = $2.to_i
      seconds = $3 ? $3.to_i : 0
      milliseconds = $4 ? $4.to_i : 0

      return hours * 3600 + minutes * 60 + seconds + (milliseconds / 1000.0)
    end

    # Invalid format
    nil
  end

  private

  # Read tags from MP4 file
  def self.read_mp4_tags(file_path)
    begin
      # For debugging, dump the file structure with ffprobe
      if debug? && system("which ffprobe > /dev/null 2>&1")
        puts "File structure (ffprobe):"
        system("ffprobe -v quiet -show_format -show_streams \"#{file_path}\"")
      end

      # Use direct TagLib file operations
      begin
        TagLib::MP4::File.open(file_path) do |file|
          if file.tag.nil?
            warn "No MP4 tag found"
            return nil
          end

          tag = file.tag
          playtag_value = nil

          # Try different known method names for accessing all items
          if tag.respond_to?(:item_map)
            if debug?
              puts "Trying to access tags via item_map..."
              tag.item_map.each_pair do |key, value|
                puts "  [#{key.inspect}, #{value.inspect}]"
              end
            end

            # Use has_key? method instead of key? for better compatibility
            if tag.item_map.has_key?(PLAYTAG_KEY) || tag.item_map.include?(PLAYTAG_KEY)
              item = tag.item_map[PLAYTAG_KEY]
              if item.respond_to?(:to_string_list)
                playtag_value = item.to_string_list.first.to_s
              else
                playtag_value = item.to_s
              end
            end
          end

          if playtag_value
            debug "Found playtag: #{playtag_value}"
            return playtag_value
          else
            debug "No playtag found via TagLib"
          end
        end
      rescue => e
        warn "Error with TagLib: #{e.message}"
      end

      return nil
    rescue => e
      warn "Error reading MP4 file: #{e.message}"
      return nil
    end
  end

  # Write tags to MP4 file
  def self.write_mp4_tags(file_path, tag_value)
    begin
      # Create a backup before modifying
      backup_file(file_path) if ENV['PLAYTAG_BACKUP'] == '1'

      success = false

      # Try TagLib first
      begin
        TagLib::MP4::File.open(file_path) do |file|
          if file.tag.nil?
            warn "Error: No MP4 tag found, cannot write"
            return false
          end

          tag = file.tag

          # Get available methods
          debug "Available methods on MP4::Tag for writing:"
          write_methods = tag.methods.grep(/set|add|item|remove/).sort
          debug_methods = write_methods if debug?

          # Try to use item_map or remove_item + add_item
          if tag.respond_to?(:remove_item) && tag.respond_to?(:item_map)
            debug "Trying remove_item and item_map..."
            begin
              # First remove the existing item if any
              tag.remove_item(PLAYTAG_KEY)

              # Create a proper MP4::Item object
              # The correct way to create a string item in MP4 format
              tag_array = [tag_value]  # Put the string in an array
              item = TagLib::MP4::Item.from_string_list(tag_array)

              # Now assign the properly created item
              tag.item_map[PLAYTAG_KEY] = item
              success = true
            rescue => e
              warn "Error with remove_item/item_map: #{e.message}"
            end
          end

          # Save if any method was successful
          if success
            if file.save
              debug "Successfully wrote playtag via TagLib: #{tag_value}"
              return true
            else
              warn "Failed to save file"
              success = false
            end
          end
        end
      rescue => e
        warn "Error with TagLib: #{e.message}"
      end

      return success
    rescue => e
      warn "Error writing to MP4 file: #{e.message}"
      return false
    end
  end

  # Read tags from MP3 file
  def self.read_mp3_tags(file_path)
    begin
      TagLib::MPEG::File.open(file_path) do |file|
        unless file.id3v2_tag
          warn "No ID3v2 tag found"
          return nil
        end

        # Look for TXXX frame with playtag
        tag = file.id3v2_tag
        frames = tag.frame_list("TXXX")

        playtag_frame = frames.find { |frame| frame.field_list.first == "PLAYTAG" }

        if playtag_frame
          playtag_value = playtag_frame.field_list.last
          debug "Found playtag: #{playtag_value}"
          return playtag_value
        else
          debug "No playtag found"
          return nil
        end
      end
    rescue => e
      warn "Error reading MP3 file: #{e.message}"
      return nil
    end
  end

  # Write tags to MP3 file
  def self.write_mp3_tags(file_path, tag_value)
    begin
      # Create a backup before modifying
      backup_file(file_path) if ENV['PLAYTAG_BACKUP'] == '1'

      TagLib::MPEG::File.open(file_path) do |file|
        tag = file.id3v2_tag(true)

        # Remove existing PLAYTAG frames
        frames = tag.frame_list("TXXX")
        frames.each do |frame|
          if frame.field_list.first == "PLAYTAG"
            tag.remove_frame(frame)
          end
        end

        # Add new PLAYTAG frame
        frame = TagLib::ID3v2::UserTextIdentificationFrame.new
        frame.description = "PLAYTAG"
        frame.text = tag_value
        tag.add_frame(frame)

        # Save the changes
        if file.save
          debug "Successfully wrote playtag: #{tag_value}"
          return true
        else
          warn "Failed to save file"
          return false
        end
      end
    rescue => e
      warn "Error writing to MP3 file: #{e.message}"
      return false
    end
  end

  # Read tags from FLAC file
  def self.read_flac_tags(file_path)
    begin
      TagLib::FLAC::File.open(file_path) do |file|
        unless file.xiph_comment
          warn "No Xiph Comment found"
          return nil
        end

        tag = file.xiph_comment

        if tag.contains?("PLAYTAG")
          playtag_value = tag.field_list_map["PLAYTAG"].first
          debug "Found playtag: #{playtag_value}"
          return playtag_value
        else
          debug "No playtag found"
          return nil
        end
      end
    rescue => e
      warn "Error reading FLAC file: #{e.message}"
      return nil
    end
  end

  # Write tags to FLAC file
  def self.write_flac_tags(file_path, tag_value)
    begin
      # Create a backup before modifying
      backup_file(file_path) if ENV['PLAYTAG_BACKUP'] == '1'

      TagLib::FLAC::File.open(file_path) do |file|
        tag = file.xiph_comment(true)

        # Set the playtag
        tag.add_field("PLAYTAG", tag_value, true)

        # Save the changes
        if file.save
          debug "Successfully wrote playtag: #{tag_value}"
          return true
        else
          warn "Failed to save file"
          return false
        end
      end
    rescue => e
      warn "Error writing to FLAC file: #{e.message}"
      return false
    end
  end

  # Create a backup of the file
  def self.backup_file(file_path)
    backup_path = "#{file_path}.bak"

    # Don't overwrite existing backups
    return if File.exist?(backup_path)

    begin
      FileUtils.cp(file_path, backup_path)
      debug "Created backup: #{backup_path}"
    rescue => e
      warn "Warning: Failed to create backup: #{e.message}"
    end
  end

  # Utility methods for output
  def self.debug?
    ENV['PLAYTAG_DEBUG'] == '1'
  end

  def self.debug(message)
    puts message if debug?
  end

  def self.warn(message)
    $stderr.puts "playtag: #{message}"
  end
end

class PlaytagEditor
  def self.edit(file_path)
    # Check if file exists
    unless File.exist?(file_path)
      PlaytagTag.warn "Error: File not found: #{file_path}"
      return false
    end

    # Read current tag
    current_tag = PlaytagTag.read(file_path)
    init_text = current_tag || "#{PlaytagTag::VERSION}; "

    # Use readline for editing
    Readline.pre_input_hook = -> { Readline.insert_text(init_text) }
    begin
      new_tag = Readline.readline('Edit tag: ', true)
      Readline.pre_input_hook = nil

      if new_tag.empty?
        PlaytagTag.warn "Empty line; deleting tag instead."
        # Delete tag logic depends on file type - we'll just pass an empty string
        return PlaytagTag.write(file_path, "")
      else
        return PlaytagTag.write(file_path, new_tag)
      end
    rescue Interrupt
      puts "\nCancelled"
      return false
    ensure
      Readline.pre_input_hook = nil
    end
  end
end

class PlaytagVLC
  def self.play(file_path, vlc_args = [])
    # Check if file exists
    unless File.exist?(file_path)
      PlaytagTag.warn "Error: File not found: #{file_path}"
      return false
    end

    # Find VLC executable
    vlc_exe = find_vlc_executable
    unless vlc_exe
      PlaytagTag.warn "Error: VLC executable not found"
      return false
    end

    # Read playtag
    tag = PlaytagTag.read(file_path)
    command = [vlc_exe]

    # Add VLC arguments
    command.concat(vlc_args)

    # If tag exists, parse it and add VLC-specific options
    if tag && !tag.empty?
      opts = PlaytagTag.parse_tag_to_options(tag)

      # Handle volume adjustment
      if opts['vol']
        if opts['vol'] =~ /([+-]?\d+(?:\.\d+)?)\s*dB/
          db_value = $1.to_f
          command << "--gain=#{db_value / 20.0}"
        end
      end

      # Handle time ranges
      if opts['t']
        # Parse time range (start-stop, start-, -stop)
        if opts['t'] =~ /^(\d+:?\d*:?\d*(?:\.\d+)?)-(\d+:?\d*:?\d*(?:\.\d+)?)$/
          start_time = PlaytagTag.parse_time($1)
          stop_time = PlaytagTag.parse_time($2)

          command << "--start-time=#{start_time.to_i}" if start_time
          command << "--stop-time=#{stop_time.to_i}" if stop_time
        elsif opts['t'] =~ /^(\d+:?\d*:?\d*(?:\.\d+)?)-$/
          start_time = PlaytagTag.parse_time($1)
          command << "--start-time=#{start_time.to_i}" if start_time
        elsif opts['t'] =~ /^-(\d+:?\d*:?\d*(?:\.\d+)?)$/
          stop_time = PlaytagTag.parse_time($1)
          command << "--stop-time=#{stop_time.to_i}" if stop_time
        elsif opts['t'] =~ /^(\d+:?\d*:?\d*(?:\.\d+)?)$/
          start_time = PlaytagTag.parse_time($1)
          command << "--start-time=#{start_time.to_i}" if start_time
        end
      end

      # Handle audio-video sync
      if opts['av-delay']
        if opts['av-delay'] =~ /([+-]?\d+(?:\.\d+)?)/
          delay_ms = $1.to_f * 1000
          command << "--audio-desync=#{delay_ms.to_i}"
        end
      end

      # Handle aspect ratio
      if opts['aspect-ratio']
        command << "--aspect-ratio=#{opts['aspect-ratio']}"
      end

      # Handle mirroring (horizontal flip)
      if opts['mirror']
        command << "--video-filter=transform{type=hflip}"
      end
    end

    # Add the file to play
    command << file_path

    # Run VLC
    system(*command)
  end

  private

  def self.find_vlc_executable
    # Check common locations
    vlc_paths = [
      'vlc',
      '/usr/bin/vlc',
      '/usr/local/bin/vlc',
      '/Applications/VLC.app/Contents/MacOS/VLC',
      'C:\\Program Files\\VideoLAN\\VLC\\vlc.exe',
      'C:\\Program Files (x86)\\VideoLAN\\VLC\\vlc.exe'
    ]

    vlc_paths.each do |path|
      return path if system("which #{path} > /dev/null 2>&1")
    end

    nil
  end
end

# Main program
if __FILE__ == $PROGRAM_NAME
  # Parse command-line options
  options = {}
  option_parser = OptionParser.new do |opts|
    opts.banner = "Usage: playtag COMMAND [options] [file]"
    opts.separator ""
    opts.separator "Commands:"
    opts.separator "  read FILE                   Read playtag from FILE"
    opts.separator "  write FILE TAG              Write TAG to FILE"
    opts.separator "  edit FILE                   Edit playtag for FILE interactively"
    opts.separator "  vlc [VLC_ARGS] FILE         Play FILE with VLC using playtag parameters"
    opts.separator ""
    opts.separator "Options:"

    opts.on("-d", "--debug", "Enable debug output") do
      ENV['PLAYTAG_DEBUG'] = '1'
    end

    opts.on("-b", "--backup", "Create backup files before modifying") do
      ENV['PLAYTAG_BACKUP'] = '1'
    end

    opts.on("-h", "--help", "Show this help message") do
      puts opts
      exit
    end
  end

  begin
    option_parser.parse!

    if ARGV.empty?
      puts option_parser
      exit 1
    end

    command = ARGV.shift

    case command
    when "read"
      if ARGV.empty?
        PlaytagTag.warn "Error: Missing file argument"
        exit 1
      end

      file_path = ARGV.shift
      tag = PlaytagTag.read(file_path)
      puts tag if tag

    when "write"
      if ARGV.size < 2
        PlaytagTag.warn "Error: Missing file or tag argument"
        exit 1
      end

      file_path = ARGV.shift
      tag_value = ARGV.shift

      # Check if the file is a phone video MP4 file
      if file_path =~ /VID_\d+/ && File.extname(file_path).downcase == ".mp4"
        puts "Warning: This appears to be a phone video file."
        puts "Writing tags to these files may corrupt them."
        puts "A backup will be created before writing."
        puts "Continue? (y/n)"

        response = STDIN.gets.chomp.downcase
        if response != 'y'
          puts "Operation cancelled"
          exit 0
        end
      end

      success = PlaytagTag.write(file_path, tag_value)
      exit(success ? 0 : 1)

    when "edit"
      if ARGV.empty?
        PlaytagTag.warn "Error: Missing file argument"
        exit 1
      end

      file_path = ARGV.shift
      success = PlaytagEditor.edit(file_path)
      exit(success ? 0 : 1)

    when "vlc"
      if ARGV.empty?
        PlaytagTag.warn "Error: Missing file argument"
        exit 1
      end

      # Last argument is the file, everything else is VLC args
      file_path = ARGV.pop
      vlc_args = ARGV

      success = PlaytagVLC.play(file_path, vlc_args)
      exit(success ? 0 : 1)

    else
      PlaytagTag.warn "Unknown command: #{command}"
      puts option_parser
      exit 1
    end

  rescue OptionParser::InvalidOption => e
    PlaytagTag.warn e.message
    puts option_parser
    exit 1
  rescue => e
    PlaytagTag.warn "Error: #{e.message}"
    exit 1
  end
end
